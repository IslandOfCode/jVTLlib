a:=3.14596
b:=-100.675
c:=3
d:=10
e:=3.0

r1:=ceil(b)  //ok
r2:=floor(b) //ok

/* I seguenti valori sono in un certo senso precisi, anche se non sembra
 * Questo perchè bisogna considerare l'arrotondamento (lo spazio che ho inserito)
 * Quindi otterremo:
 	r3=    3.1
 	r4= -100.68
 	r5=    3.146
 	r6= -100.675
 	r7=    3.14596
 * anche se sembra che solo r6 e r7 siano corretti, in realtà lo sono tutti
 * a meno di eps o comunque dell'errore di arrotondamento (Analisi Numerica docet)
 *
 * Per avere una precisione matematica, cambiare semplicemente il metodo di arrotondamento.
 */
r3:=round(a,1)	//torna 3.0999999 046325684 come float
r4:=round(b,2)	//torna -100.68 000030517578 come float
r5:=round(a,3)	//torna 3.1459999 084472656 come float
r6:=round(b,3)	//torna -100.675 00305175781 come float
r7:=round(a,7)	//torna 3.14596 00925445557 come float

r8:=abs(b)			//ok
r9:=exp(c)			//ok, da 20 perchè integer
r9b:=exp(e)			//ok, circa, esce 20.08553695678711, google calc = 20.0855369232
r10:=ln(c)			//ok, da 1 perchè integer
r10b:=ln(e)			//ok, circa, esce 1.0986123085021973, google calc = 1.09861228867
r11:=sqrt(c)		//ok, da 1 perchè integer
r11b:=sqrt(e)		//ok, circa, esce 1.7320507764816284, google cals = 1.73205080757

r12:=trunc(a,3)		//torna 3.14 49999809265137 come float
r13:=power(c,3)		//ok, torna 27 come integer
r14:=nroot(c,4)		//torna 1, bisogna verificare con cifre più consone {???}
r15:=mod(d,3)		//torna 1 come intero, ok!

nop

/*stringhe!*/
A:="Hello, world!"
//Gli esempio del libro sono errati!
B:=substr(A,2)		//B = "lo, world!"	B = "llo, world!"
C:=substr(A,2,5)	//C = "lo, w"		C = "llo, "
D:=substr(A,0,4)	//D = "Hell"		D = "Hell"

X:="Hello,"
Y:=" world!"
Z:=X||Y||" Ciaone proprio!"
W:=X||"Hello,"||" world!"

nop

ds1:=get("random")

define datapoint ruleset rs1(NAME,AGE){
	RL11: when NAME="peppe" then isnull(AGE) errorcode("regola 1 fallita")
}

define datapoint ruleset rs2(AGE){
	RL21: when true then not isnull(AGE) errorcode("regola 21 fallita")
	RL22: when true then AGE>18 and AGE<22 errorcode("regola 22 fallita")
}

define datapoint ruleset rs3(NAME,AGE){
	RL13: when AGE in("18","20") then NAME="peppe" errorcode("regola 3 fallita")
}

//debug
ctst:=check(ds1,rs3)
printvar ctst

chk1:=check(ds1,rs1,valid,condition)
chk2:=check(ds1,rs1,not valid,condition)
chk3:=check(ds1,rs1,all,condition)
chk4:=check(ds1,rs1,valid,measures)
chk5:=check(ds1,rs1,not valid,measures)
dschk:=check(ds1,rs1,rs2,rs3)

printvar ds1

printvar chk1
printvar chk2
printvar chk3
printvar chk4
printvar chk5
printvar dschk

dsc1:=ds1[calc("80" as "WEIGHT" role attribute)]
printvar dsc1
dsc2:=ds1[calc(AGE as "WEIGHT" role attribute)]
printvar dsc2
dsc3:=ds1[calc((AGE+80) as "WEIGHT" role attribute)]
printvar dsc3
dsc4:=ds1[calc(isnull(NAME) as "NAMEISNULL" role attribute)]
printvar dsc4
dsc5:=ds1[calc((NAME="peppe") as "isPEPPE" role attribute)]
printvar dsc5

dsret:=ds1[
	rename(ID as "ID_NEW", NAME role measure, AGE role attribute),
	keep(ID_NEW,NAME),
	filter(NAME="peppe")
	]

printvar dsret


dsf1:=ds1[filter(NAME="peppe" and AGE="21")]
printvar dsf1


//funziona sia as che role in qualsiasi posizione
dsk1:=ds1[keep(ID role measure,AGE role identifier)]
dsk2:=ds1[rename(ID as "ID_NEW" role measure, AGE role identifier)]
dsk3:=ds1[rename(ID as "COD"),keep(COD,AGE)]

printvar dsk1
printvar dsk2
printvar dsk3


b:=get("random")
printvar ds1

dsr1:=union(ds1)
printvar dsr1

ds2:=b[
	filter(NAME="peppe"),
	calc((AGE*2) as "AGE")
]
printvar ds2

ds3:=b[
	rename(ID as "NEWID" role attribute)
]
printvar ds3

ds4:=b[ calc("T" as "TMP" role attribute)]
printvar ds4

dsr:=union(ds1,ds4)
//dsr:=union(ds4,ds1)

dsr:=union(ds1,ds2)
//questo lancia eccezione!
//dsr:=union(ds1,ds3)
printvar dsr


nop
